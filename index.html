<!DOCTYPE html>
<html lang="no">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IRL Gjemsel</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <!-- Turf.js -->
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

  <style>
    /* Leaderboard styles */
    #leaderboard {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1000;
      background: rgba(255,255,255,0.94);
      padding: 10px 12px;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.2);
      max-width: 300px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    #leaderboard h2 {
      margin: 0 0 10px;
      font-size: 16px;
    }
    #leaderboard-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    #leaderboard-list li {
      padding: 4px 0;
      border-bottom: 1px solid rgba(0,0,0,0.1);
    }
    #leaderboard-list li:last-child {
      border-bottom: none;
    }
    #nickname-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 32px rgba(0,0,0,0.3);
      z-index: 2000;
      display: none;
    }
    #nickname-modal input {
      width: 100%;
      padding: 8px;
      margin: 10px 0;
      border: 1px solid #ccc;
      border-radius: 6px;
    }
    #nickname-modal button {
      width: 100%;
      padding: 8px;
      background: #2b7;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }

    html, body, #map { height: 100%; margin: 0; }
    .hidden { display: none !important; }
    
    /* Leaderboard styles */
    #leaderboard {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1000;
      background: rgba(255,255,255,0.94);
      padding: 10px 12px;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.2);
      max-width: 300px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    #leaderboard h2 {
      margin: 0 0 10px;
      font-size: 16px;
      display: inline-block;
    }
    #toggleLeaderboard {
      float: right;
      border: none;
      background: #eee;
      border-radius: 10px;
      padding: 6px 8px;
      cursor: pointer;
      font-weight: 700;
    }
    #leaderboard.min #leaderboard-list {
      display: none;
    }
    #leaderboard.min h2 {
      display: none;
    }
    #leaderboard.min {
      opacity: 0.92;
      padding: 6px;
      background: transparent;
      box-shadow: none;
    }
    #leaderboard.min #toggleLeaderboard {
      float: none;
      font-size: 20px;
      padding: 8px 12px;
      background: rgba(255,255,255,0.94);
      box-shadow: 0 4px 16px rgba(0,0,0,0.2);
    }
    #leaderboard-list {
      list-style: none;
      padding: 0;
      margin: 0;
      clear: both;
    }
    #leaderboard-list li {
      padding: 4px 0;
      border-bottom: 1px solid rgba(0,0,0,0.1);
      font-size: 14px;
    }
    #leaderboard-list li:last-child {
      border-bottom: none;
    }
    
    /* Nickname modal styles */
    #nickname-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 32px rgba(0,0,0,0.3);
      z-index: 2000;
      display: none;
      width: 300px;
      text-align: center;
    }
    #nickname-modal h3 {
      margin: 0 0 10px;
      font-size: 18px;
    }
    #nickname-modal input {
      width: calc(100% - 20px);
      padding: 8px;
      margin: 10px 0;
      border: 1px solid #ccc;
      border-radius: 6px;
      font-size: 16px;
    }
    #nickname-modal button {
      width: 100%;
      padding: 10px;
      background: #2b7;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      margin-top: 10px;
    }
    #nickname-modal button:hover {
      background: #1a6;
    }
    #hud {
      position: absolute; top: 10px; left: 10px; z-index: 1000;
      background: rgba(255,255,255,0.94); padding: 10px 12px; border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.2); max-width: 380px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      transition: max-height .2s ease, opacity .2s ease;
    }
    #hud.min .row:not(:first-child) { display: none; }
    #hud.min { opacity: .92; }
    #hud.min h1 { display: none; }
    #hud h1 { margin: 0 0 6px; font-size: 16px; display: inline-block; }
    #toggleHud {
      float: right; border: none; background: #eee; border-radius: 10px; padding: 6px 8px;
      cursor: pointer; font-weight: 700;
    }
    #hud .row { display: flex; gap: 8px; align-items: center; margin: 6px 0; flex-wrap: wrap; }
    #hud label { font-size: 12px; }
    #hud input[type="file"] { width: 100%; }
    #hud button { padding: 8px 10px; margin-right:10px; float:left;border-radius: 10px; background: #2b7; color: #fff; font-weight: 600; cursor: pointer; }
    #hud button.secondary { background: #777; }
    #hud button:disabled { opacity: .6; cursor: not-allowed; }
    #status { margin-top: 6px; font-size: 13px; }
    #countdown {
      position: absolute; left: 50%; bottom: 80px;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.75); color: #fff; 
      padding: 12px 24px; border-radius: 12px;
      font-size: 24px; z-index: 1200; display: none; 
      text-align: center; font-weight: 600;
      box-shadow: 0 4px 16px rgba(0,0,0,0.2);
    }
    #stopwatch {
      position: absolute; left: 50%; bottom: 20px;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.75); color: #fff; 
      padding: 8px 16px; border-radius: 12px;
      font-size: 18px; z-index: 1200; display: none; 
      text-align: center; font-weight: 600;
      box-shadow: 0 4px 16px rgba(0,0,0,0.2);
    }
    #overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.7); z-index: 1100;
      display: none; cursor: pointer;
    }
    #caught {
      position: absolute; top: 50%; left: 50%; 
      transform: translate(-50%, -50%);
      background: linear-gradient(to right, rgb(200,0,0), rgb(180,0,0));
      color: #fff; padding: 24px 48px; border-radius: 16px;
      font-size: 32px; z-index: 1200; display: none; 
      font-weight: 800; text-align: center;
      box-shadow: 0 4px 32px rgba(0,0,0,0.5);
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    #caught:hover {
      transform: translate(-50%, -50%) scale(1.02);
      box-shadow: 0 6px 40px rgba(0,0,0,0.6);
    }
    .legend {
      position: absolute; right: 10px; bottom: 10px; z-index: 1000;
      background: rgba(255,255,255,.92); padding: 8px 10px; border-radius: 10px; font-size: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,.15);
    }
    .hint { font-size: 12px; color: #333; line-height: 1.4; }
    .warn {
      position: absolute; left: 50%; bottom: 70px; transform: translateX(-50%);
      background: rgba(255,165,0,.95); color: #000; padding: 8px 12px; border-radius: 10px; z-index: 1200; display: none;
      font-weight: 700; font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="overlay"></div>
  <div id="hud" class="min">
    <button id="toggleHud" title="Minimer/utvid">+</button>
    <h1>IRL Sp√∏kelsesspill üëª</h1>
    

    <div class="row">
      <button id="btnStart">Start (20s gjemmetid)</button>
      <button id="btnReset" class="secondary">Reset</button>
    </div>

    <div class="row">
      <label for="ghosts">Sp√∏kelser:</label>
      <input id="ghosts" type="number" value="5" min="1" max="100" style="width:70px"/>
      <label for="speed" title="hastighet m/s">Hastighet:</label>
      <input id="speed" type="number" value="5.5" min="0.5" max="15" step="0.1" style="width:70px"/>
    </div>

    <div class="row">
      <label for="fov" title="Synsfelt i grader">FOV¬∞:</label>
      <input id="fov" type="number" value="95" min="30" max="180" step="5" style="width:70px"/>
      <label for="viewDist" title="Synsrekkevidde i meter">Rekkevidde(m):</label>
      <input id="viewDist" type="number" value="70" min="10" max="200" step="5" style="width:80px"/>
    </div>

    <div class="row hidden">
      <label for="prox" title="Fanges innenfor denne avstanden, uansett syn">N√¶rhet(m):</label>
      <input id="prox" type="number" value="0" min="1" max="30" step="1" style="width:80px"/>
    </div>

    <div class="row hidden" style="flex-direction: column; align-items: stretch;">
      <label><b>Last GeoJSON-avgrensning (valgfritt)</b></label>
      <input id="geojsonBoundary" type="file" accept=".geojson,.json,application/geo+json"/>
      <div class="hint">Polygon/multipolygon som omkranser spilleomr√•det. Uten fil: sirkel 500 m.</div>
    </div>



    <div id="status" class="hint">
      Klargj√∏ring‚Ä¶ gi tillatelse til posisjon (GPS). Du kan ogs√• trykke i kartet for √• sette posisjon manuelt.
    </div>
  </div>

    <div class="legend">
      <div>üü¢ Avgrensning</div>
      <div>üîµ Du</div>
      <div>üî¥ Sp√∏kelser + lyskjegle</div>
    </div>  <div id="countdown"></div>
  <div id="stopwatch"></div>
  <div id="caught">Du ble funnet! üëª</div>
  <div id="warn" class="warn"></div>

  <div id="leaderboard" class="min">
    <h2>Toppliste üèÜ</h2>
    <button id="toggleLeaderboard" title="Minimer/utvid">üèÜ</button>
    <ul id="leaderboard-list"></ul>
  </div>

  <div id="nickname-modal">
    <h3>Gratulerer! Du er p√• topp 10!</h3>
    <p>Skriv inn navnet ditt:</p>
    <input type="text" id="nickname-input" maxlength="50" placeholder="Navn">
    <button id="save-nickname">Lagre</button>
  </div>

<script>
(function() {
  // Firebase configuration and initialization
  const firebaseConfig = {
    apiKey: "AIzaSyC6Dtf_R_xe-zWORr1T4-jkpqfaNmkeHj4",
    authDomain: "irl-gjemsel.firebaseapp.com",
    databaseURL: "https://irl-gjemsel-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "irl-gjemsel",
    storageBucket: "irl-gjemsel.firebasestorage.app",
    messagingSenderId: "809549687443",
    appId: "1:809549687443:web:4fc9a3d18a5205dadefb66"
  };
  
  // Initialize Firebase
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();
  const leaderboardRef = db.ref('leaderboard');
  
  // Configure database URL explicitly
  db.refFromURL('https://irl-gjemsel-default-rtdb.europe-west1.firebasedatabase.app');

  // Leaderboard functions
  function updateLeaderboardDisplay(scores) {
    const leaderboardList = document.getElementById('leaderboard-list');
    leaderboardList.innerHTML = '';
    scores.forEach((score, index) => {
      const li = document.createElement('li');
      const time = Math.floor(score.time);
      const minutes = Math.floor(time / 60);
      const seconds = (time % 60).toString().padStart(2, '0');
      li.textContent = `${index + 1}. ${score.playerName} - ${minutes}:${seconds} (üëª ${score.ghostCount})`;
      leaderboardList.appendChild(li);
    });
  }

  function loadLeaderboard() {
    leaderboardRef.orderByChild('time').limitToLast(5).once('value', snapshot => { // Changed to limitToLast to get highest values
      const scores = [];
      snapshot.forEach(childSnapshot => {
        scores.push(childSnapshot.val());
      });
      scores.sort((a, b) => b.time - a.time); // Sort by longest time first
      updateLeaderboardDisplay(scores);
    });
  }

  async function checkHighScore(time, ghostCount) {
    const snapshot = await leaderboardRef.orderByChild('time').limitToFirst(1).once('value');
    let isTop10 = false;
    let scores = [];
    
    await leaderboardRef.orderByChild('time').once('value', snapshot => {
      snapshot.forEach(childSnapshot => {
        scores.push(childSnapshot.val());
      });
    });
    
    scores.sort((a, b) => b.time - a.time); // Sort by longest time first
    
    if (scores.length < 10 || time > scores[9].time) { // Changed condition to check for longer time
      isTop10 = true;
    }
    
    if (isTop10) {
      return new Promise((resolve) => {
        const modal = document.getElementById('nickname-modal');
        const input = document.getElementById('nickname-input');
        const saveBtn = document.getElementById('save-nickname');
        
        modal.style.display = 'block';
        
        saveBtn.onclick = () => {
          const playerName = input.value.trim();
          if (playerName) {
            leaderboardRef.push({
              playerName,
              time,
              ghostCount,
              timestamp: firebase.database.ServerValue.TIMESTAMP
            });
            modal.style.display = 'none';
            loadLeaderboard();
            resolve();
          }
        };
      });
    }
  }

  // Load leaderboard on startup
  loadLeaderboard();

  // Setup leaderboard toggle
  const toggleLeaderboard = document.getElementById('toggleLeaderboard');
  toggleLeaderboard.addEventListener('click', () => {
    const leaderboard = document.getElementById('leaderboard');
    leaderboard.classList.toggle('min');
    toggleLeaderboard.textContent = leaderboard.classList.contains('min') ? 'üèÜ' : '‚àí';
  });

  // --- Kart ---
  const map = L.map('map', { zoomControl: true });
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    minZoom: 1,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);
  map.setView([58.1467, 7.9956], 15); // Kristiansand

  // UI
  const $ = (id)=>document.getElementById(id);
  const btnStart=$('btnStart'), btnReset=$('btnReset'), toggleHud=$('toggleHud');
  const inputGhosts=$('ghosts'), inputSpeed=$('speed'), inputFov=$('fov'), inputViewDist=$('viewDist'), inputProx=$('prox');
  const fileBoundary=$('geojsonBoundary');
  const statusEl=$('status'), countdownEl=$('countdown'), caughtEl=$('caught'), stopwatchEl=$('stopwatch'), warnEl=$('warn');
  const hud=$('hud');

  toggleHud.addEventListener('click', ()=>{
    hud.classList.toggle('min');
    toggleHud.textContent = hud.classList.contains('min') ? '+' : '‚àí';
  });

  const STATE={IDLE:'idle', COUNTDOWN:'countdown', RUNNING:'running', CAUGHT:'caught'};
  const Game={
    state:STATE.IDLE, tickMs:100, hideSeconds:10, timer:null, watcher:null,
    startedAt:null, stopwatchTimer:null, shrunk:false, shrinkTimeSec:20,
    spawnGhostInterval: 5, // Seconds between new ghost spawns
    lastGhostSpawn: null,
    maxGhosts: 25 // Maximum number of ghosts that can be spawned
  };

  // Geometri
  let boundaryLayer=null, boundaryPoly=null; // Turf (Polygon/MultiPolygon)
  let boundaryIsCircle=false; // spesiell h√•ndtering (radius/center)
  let boundaryCircleCenter=null, boundaryCircleRadiusM=100; // default radius
  let originalBoundaryGeom=null; // for krymp-logikk

  let obstaclesLayer=null; // Leaflet group
  let obstaclesPolys=[];   // Turf Polygon/MultiPolygon

  // Spiller
  let playerMarker=null, playerAccuracy=null, playerLatLng=null;

  // Sp√∏kelser
  const ghosts=[];

  // --- Turf helpers ---
  const tPoint = (ll)=>turf.point([ll.lng, ll.lat]);
  const metersBetween=(a,b)=>turf.distance(tPoint(a), tPoint(b), {units:'kilometers'})*1000;
  const bearingTo=(from,to)=>turf.bearing([from.lng,from.lat],[to.lng,to.lat]);
  const moveFrom=(ll, bearingDeg, meters)=>{
    const d=turf.destination([ll.lng,ll.lat], meters/1000, bearingDeg, {units:'kilometers'});
    const [lng,lat]=d.geometry.coordinates; return L.latLng(lat,lng);
  };
  const pointInside=(poly,ll)=>turf.booleanPointInPolygon([ll.lng,ll.lat], poly);
  const lineWithin=(poly,a,b)=>{
    const line=turf.lineString([[a.lng,a.lat],[b.lng,b.lat]]);
    try { return turf.booleanContains(poly, line); } catch(e){ return false; }
  };
  const lineIntersectsAnyObstacle=(a,b)=>{
    if (!obstaclesPolys.length) return false;
    // Create a short buffer around the line to ensure reliable intersection detection
    const line = turf.lineString([[a.lng,a.lat], [b.lng,b.lat]]);
    const bufferedLine = turf.buffer(line, 0.001, {units: 'kilometers'}); // 1m buffer
    for (const poly of obstaclesPolys) {
      try {
        // Check if the buffered line intersects the obstacle
        if (turf.booleanIntersects(bufferedLine, poly)) {
          return true;
        }
      } catch(e){
        // If there's an error, assume there is an intersection to be safe
        return true;
      }
    }
    return false;
  };
  const pointInsideAnyObstacle=(ll)=>{
    if (!obstaclesPolys.length) return false;
    const pt=[ll.lng, ll.lat];
    for (const poly of obstaclesPolys){
      try { if (turf.booleanPointInPolygon(pt, poly)) return true; } catch(e){}
    }
    return false;
  };
  function setStatus(msg){ statusEl.textContent=msg; }
  function flashWarn(msg){
    warnEl.textContent = msg;
    warnEl.style.display = 'block';
    clearTimeout(flashWarn._t);
    flashWarn._t = setTimeout(()=> warnEl.style.display='none', 1200);
  }

  // --- Boundary ---
  function drawBoundary(poly){
    if (boundaryLayer){ map.removeLayer(boundaryLayer); }
    boundaryLayer=L.geoJSON(poly,{ style:{color:'#2a2',weight:2,fillOpacity:.06,fillColor:'#5f5'} }).addTo(map);
  }
  function setBoundary(poly, isCircle=false){
    boundaryPoly=poly;
    boundaryIsCircle=isCircle;
    originalBoundaryGeom = turf.clone(poly);
    drawBoundary(poly);
    try { map.fitBounds(boundaryLayer.getBounds(), {padding:[30,30]}); } catch (e){}
  }
  function ensureDefaultBoundary(center){
    const c=center||map.getCenter();
    boundaryCircleCenter = L.latLng(c.lat, c.lng);
    boundaryCircleRadiusM = 200; // ‚Üê 500 m default
    const circle=turf.circle([c.lng,c.lat], boundaryCircleRadiusM/1000, {units:'kilometers',steps:64});
    setBoundary(circle, true);
  }
  function shrinkBoundaryTo80(){
    if (Game.shrunk || !boundaryPoly) return;
    Game.shrunk = true;

    if (boundaryIsCircle && boundaryCircleCenter){
      boundaryCircleRadiusM = boundaryCircleRadiusM * 0.8; // 80% radius
      const circle=turf.circle([boundaryCircleCenter.lng,boundaryCircleCenter.lat], boundaryCircleRadiusM/1000, {units:'kilometers',steps:64});
      boundaryPoly = circle;
      drawBoundary(circle);

      // Move ghosts inside the new boundary if they're outside
      for (const ghost of ghosts) {
        if (!pointInside(boundaryPoly, ghost.latlng)) {
          // Calculate vector from center to ghost
          const bearing = bearingTo(boundaryCircleCenter, ghost.latlng);
          // Place ghost at 80% of the new radius
          const safeDistance = boundaryCircleRadiusM * 0.8;
          const newPos = moveFrom(boundaryCircleCenter, bearing, safeDistance);
          // Update ghost position
          ghost.latlng = newPos;
          ghost.marker.setLatLng(newPos);
          ghost.cone.setLatLngs(ghost.computeCone());
        }
      }
      
      setStatus('Omr√•de krympet til 80% av st√∏rrelsen. Sp√∏kelser flyttet innfor nytt omr√•de.');
      return;
    }
    // Polygon: skaler mot centroid slik at arealet ~80% (skalafaktor sqrt(0.8))
    const scale = Math.sqrt(0.8); // ‚âà 0.894427
    const centroid = turf.centroid(boundaryPoly).geometry.coordinates;
    function scaleCoords(coords){
      return coords.map(ring => ring.map(([lng,lat])=>{
        const dx = lng - centroid[0], dy = lat - centroid[1];
        return [centroid[0] + dx*scale, centroid[1] + dy*scale];
      }));
    }
    let newPoly=null;
    if (boundaryPoly.type==='Feature' && boundaryPoly.geometry){
      const g=boundaryPoly.geometry;
      if (g.type==='Polygon') newPoly = turf.polygon(scaleCoords(g.coordinates));
      else if (g.type==='MultiPolygon') newPoly = turf.multiPolygon(g.coordinates.map(scaleCoords));
    } else if (boundaryPoly.type==='Polygon'){
      newPoly = turf.polygon(scaleCoords(boundaryPoly.coordinates));
    } else if (boundaryPoly.type==='MultiPolygon'){
      newPoly = turf.multiPolygon(boundaryPoly.coordinates.map(scaleCoords));
    }
    if (newPoly){
      boundaryPoly = newPoly;
      drawBoundary(newPoly);

      // Move ghosts inside the new boundary if they're outside
      const center = turf.centroid(newPoly).geometry.coordinates;
      const centerLL = L.latLng(center[1], center[0]);
      
      for (const ghost of ghosts) {
        if (!pointInside(boundaryPoly, ghost.latlng)) {
          // Calculate bearing from center to ghost
          const bearing = bearingTo(centerLL, ghost.latlng);
          
          // Try different distances from center until we find a valid position
          const maxDist = 100; // meters
          let newPos = null;
          
          for (let dist = maxDist; dist >= 10; dist -= 5) {
            const tryPos = moveFrom(centerLL, bearing, dist);
            if (pointInside(boundaryPoly, tryPos) && !pointInsideAnyObstacle(tryPos)) {
              newPos = tryPos;
              break;
            }
          }
          
          if (newPos) {
            // Update ghost position
            ghost.latlng = newPos;
            ghost.marker.setLatLng(newPos);
            ghost.cone.setLatLngs(ghost.computeCone());
          }
        }
      }
      
      setStatus('Omr√•de krympet til 80% av st√∏rrelsen. Sp√∏kelser flyttet innfor nytt omr√•de.');
    }
  }

  // Obstacle logic removed

  // --- Filinnlasting ---
  function readGeoJSONFile(file, onJSON){
    const r=new FileReader();
    r.onload=()=>{ try{ onJSON(JSON.parse(r.result)); } catch(e){ alert('Ugyldig GeoJSON: '+e.message); } };
    r.readAsText(file);
  }
  fileBoundary.addEventListener('change',(e)=>{
    const f=e.target.files && e.target.files[0]; if (!f) return;
    readGeoJSONFile(f, (gj)=>{
      // Finn polygon/multipolygon
      let poly=null;
      if (gj.type==='FeatureCollection'){
        for(const ft of gj.features){
          if (!ft.geometry) continue;
          if (ft.geometry.type==='Polygon'){ poly=turf.polygon(ft.geometry.coordinates); break; }
          if (ft.geometry.type==='MultiPolygon'){ poly=turf.multiPolygon(ft.geometry.coordinates); break; }
        }
      } else if (gj.type==='Feature' && gj.geometry){
        if (gj.geometry.type==='Polygon') poly=turf.polygon(gj.geometry.coordinates);
        if (gj.geometry.type==='MultiPolygon') poly=turf.multiPolygon(gj.geometry.coordinates);
      } else if (gj.type==='Polygon' || gj.type==='MultiPolygon'){
        poly = gj.type==='Polygon' ? turf.polygon(gj.coordinates) : turf.multiPolygon(gj.coordinates);
      }
      if (!poly){ alert('Fant ingen polygon i avgrensningsfilen.'); return; }
      setBoundary(poly, false);
      setStatus('Avgrensning lastet ‚úîÔ∏è');
    });
  });


  // --- Spiller & posisjonsvalidering ---
  function canMove(fromLL, toLL){
    if (!boundaryPoly) return true;
    // m√• v√¶re inne i boundary
    if (!pointInside(boundaryPoly, toLL)) return false;
    if (fromLL){ // sjekk linje-kryssing kun hvis vi har forrige pos
      // linjen m√• ligge i boundary
      if (!lineWithin(boundaryPoly, fromLL, toLL)) return false;
    }
    return true;
  }
  function ensurePlayer(ll, acc){
    // valider bevegelse
    if (playerLatLng && !canMove(playerLatLng, ll)){
      flashWarn('Ugyldig bevegelse (utenfor omr√•de).');
      return; // ignorer
    }
    if (!playerLatLng){ // f√∏rste posisjon
      if (boundaryPoly && !pointInside(boundaryPoly, ll)){ flashWarn('Utenfor omr√•de.'); return; }
    }
    playerLatLng=ll;
    if (!playerMarker){
      playerMarker=L.circleMarker(ll,{radius:7,weight:2,color:'#06f',fillColor:'#9cf',fillOpacity:.8}).addTo(map).bindTooltip('Du');
    } else playerMarker.setLatLng(ll);
    if (!playerAccuracy){
      playerAccuracy=L.circle(ll,{radius:acc||10,color:'#39f',weight:1,fillOpacity:.08}).addTo(map);
    } else {
      playerAccuracy.setLatLng(ll);
      if (acc) playerAccuracy.setRadius(acc);
    }
  }

  if ("geolocation" in navigator){
    Game.watcher=navigator.geolocation.watchPosition(pos=>{
      const {latitude:lat, longitude:lng, accuracy}=pos.coords;
      const ll=L.latLng(lat,lng);
      if (!boundaryPoly) ensureDefaultBoundary(ll); // 500 m sirkel
      // fors√∏k √• flytte ‚Äì hvis ugyldig, ignorer
      const before = playerLatLng;
      ensurePlayer(ll, accuracy||10);
      if (!playerLatLng && before){ /* do nothing */ }
    }, _err=>{
      setStatus('GPS avvist/feil. Trykk i kartet for √• sette posisjon.');
      if (!boundaryPoly) ensureDefaultBoundary(map.getCenter());
    }, {enableHighAccuracy:true, maximumAge:2000, timeout:8000});
  } else {
    setStatus('Ingen geolokasjon. Trykk i kartet for √• sette posisjon.');
    ensureDefaultBoundary(map.getCenter());
  }
  map.on('click', e=>{
    if (!boundaryPoly) ensureDefaultBoundary(e.latlng); // f√∏rste gang
    ensurePlayer(e.latlng, 5);
  });

  // --- Sp√∏kelse ---
  class Ghost{
    constructor(ll, opts){
      this.latlng=ll;
      this.heading=Math.random()*360;
      this.speed=opts.speed||4.2;
      this.fov=opts.fov||95;
      this.viewDist=opts.viewDist||70;
      this.proximity=opts.proximity||0;
      this.mode='patrol';
      this.lastSeenTarget=null;
      this.searchUntil=0;
      this.patrolTarget=this.pickPatrolTarget();
      this.patrolRecalcAt=Date.now()+8000+Math.random()*4000;
      this.marker=L.circleMarker(ll,{radius:6,weight:2,color:'#222',fillColor:'#f66',fillOpacity:.9}).addTo(map);
      this.cone=L.polygon(this.computeCone(),{weight:1,color:'#c44',fillColor:'#fcc',fillOpacity:.15}).addTo(map);
    }
    pickPatrolTarget(){
      if (!boundaryPoly) return null;
      const bb=turf.bbox(boundaryPoly);
      for(let tries=0; tries<60; tries++){
        const rnd=turf.randomPoint(1,{bbox:bb}).features[0];
        if (!turf.booleanPointInPolygon(rnd, boundaryPoly)) continue;
        const [lng,lat]=rnd.geometry.coordinates;
        const ll=L.latLng(lat,lng);
        if (pointInsideAnyObstacle(ll)) continue;
        return ll;
      }
      const c=turf.centroid(boundaryPoly).geometry.coordinates;
      return L.latLng(c[1], c[0]);
    }
    computeCone(){
      // Normalize heading to [0, 360)
      const normalizedHeading = ((this.heading % 360) + 360) % 360;
      
      // Calculate the exact angles for the cone edges
      const leftAngle = normalizedHeading - this.fov/2;
      const rightAngle = normalizedHeading + this.fov/2;
      
      // Create cone points with multiple segments for smoother edges
      const points = [this.latlng];
      const segments = 8; // Number of segments for the arc
      
      for (let i = 0; i <= segments; i++) {
        const angle = leftAngle + (rightAngle - leftAngle) * (i / segments);
        points.push(moveFrom(this.latlng, angle, this.viewDist));
      }
      
      return points;
    }
    seesPlayer(playerLL){
      if (!playerLL) return false;
      
      // 1. Proximity check - immediate catch if very close
      const distance = metersBetween(this.latlng, playerLL);
      if (distance <= this.proximity) return true;
      
      // 2. Distance check - too far to see
      if (distance > this.viewDist) return false;
      
      // 3. Field of view check - is player in view cone
      const bearing = bearingTo(this.latlng, playerLL);
      // Normalize both angles to [0, 360) range first
      const normalizedHeading = ((this.heading % 360) + 360) % 360;
      const normalizedBearing = ((bearing % 360) + 360) % 360;
      
      // Calculate the smallest angle between the two directions
      let angleDiff = Math.abs(normalizedBearing - normalizedHeading);
      if (angleDiff > 180) {
          angleDiff = 360 - angleDiff;
      }
      
      // Strict FOV check
      const halfFOV = this.fov / 2;
      if (angleDiff > halfFOV) return false;
      
      // 4. Line of sight check - no obstacles in the way
      // Do the line check only if we passed the angle check
      if (lineIntersectsAnyObstacle(this.latlng, playerLL)) return false;
      
      // 5. Boundary check - line of sight within boundary
      if (boundaryPoly && !lineWithin(boundaryPoly, this.latlng, playerLL)) return false;
      
      return true;
    }
    steer(dt, playerLL, allGhosts){
      const now=Date.now();
      const sees=this.seesPlayer(playerLL);
      if (sees){
        const snapshot=L.latLng(playerLL.lat, playerLL.lng);
        this.mode='chase';
        this.lastSeenTarget=snapshot;
        this.searchUntil=now+6000;
      } else if (this.mode==='chase' && this.lastSeenTarget){
        this.mode='search';
      } else if (this.mode==='search' && (!this.lastSeenTarget || now>this.searchUntil)){
        this.mode='patrol';
        this.lastSeenTarget=null;
        this.searchUntil=0;
        if (!this.patrolTarget) this.patrolTarget=this.pickPatrolTarget();
      }

      const clampHeadingDiff=(current, desired, maxTurn)=>{
        const diff=((((desired-current)%360)+540)%360)-180;
        if (Math.abs(diff)<=maxTurn) return current+diff;
        return current+(diff>0?maxTurn:-maxTurn);
      };

      let desiredHeading=this.heading;
      let moveSpeed=this.speed;

      if (this.mode==='chase' && playerLL){
        desiredHeading=bearingTo(this.latlng, playerLL);
        this.heading=clampHeadingDiff(this.heading, desiredHeading, 160*dt);
      } else if (this.mode==='search' && this.lastSeenTarget){
        desiredHeading=bearingTo(this.latlng, this.lastSeenTarget);
        const sweep=Math.sin(now/500)*35; // gentle oscillation while searching
        desiredHeading=(desiredHeading+sweep+360)%360;
        moveSpeed=this.speed*0.75;
        this.heading=clampHeadingDiff(this.heading, desiredHeading, 100*dt);
        if (metersBetween(this.latlng, this.lastSeenTarget)<8){
          this.mode='patrol';
          this.lastSeenTarget=null;
          this.searchUntil=0;
          this.patrolTarget=this.pickPatrolTarget();
          this.patrolRecalcAt=now+9000+Math.random()*6000;
        }
      } else {
        if (!this.patrolTarget || !pointInside(boundaryPoly, this.patrolTarget) || metersBetween(this.latlng, this.patrolTarget)<8 || now>this.patrolRecalcAt){
          this.patrolTarget=this.pickPatrolTarget();
          this.patrolRecalcAt=now+9000+Math.random()*6000;
        }
        if (this.patrolTarget){
          desiredHeading=bearingTo(this.latlng, this.patrolTarget);
        }
        this.heading=clampHeadingDiff(this.heading, desiredHeading, 60*dt);
        // If the patrol segment would leave the boundary, pick a new target immediately
        const probe=moveFrom(this.latlng, this.heading, this.speed*dt*2);
        if (boundaryPoly && (!pointInside(boundaryPoly, probe) || !lineWithin(boundaryPoly, this.latlng, probe))){
          this.patrolTarget=this.pickPatrolTarget();
        }
      }

      this.heading=((this.heading%360)+360)%360;

      if (Array.isArray(allGhosts) && allGhosts.length>1){
        let vx=0, vy=0;
        for(const other of allGhosts){
          if (other===this || !other.latlng) continue;
          const dist=metersBetween(this.latlng, other.latlng);
          if (!dist || dist>25) continue;
          const away=bearingTo(other.latlng, this.latlng);
          const strength=(25-dist)/25;
          const rad=away*Math.PI/180;
          vx+=Math.cos(rad)*strength;
          vy+=Math.sin(rad)*strength;
        }
        if (vx || vy){
          const sep=(Math.atan2(vy, vx)*180/Math.PI+360)%360;
          const diff=((((sep-this.heading)%360)+540)%360)-180;
          const adjust=Math.max(-25, Math.min(25, diff*0.4));
          this.heading=(this.heading+adjust+360)%360;
        }
      }

      const step=moveSpeed*dt;
      let next=moveFrom(this.latlng, this.heading, step);
      const validMove=(from,to)=>{
        if (boundaryPoly){
          if (!pointInside(boundaryPoly,to)) return false;
          if (!lineWithin(boundaryPoly, from, to)) return false;
        }
        return true;
      };
      if (!validMove(this.latlng, next)){
        const offsets=[30,-30,60,-60,90,-90,120,-120,150,-150,180];
        let fixed=null;
        for(const off of offsets){
          const h=(this.heading+off+360)%360;
          const tryPos=moveFrom(this.latlng, h, step);
          if (validMove(this.latlng, tryPos)){ fixed={h,tryPos}; break; }
        }
        if (fixed){ this.heading=fixed.h; next=fixed.tryPos; }
        else {
          next=this.latlng;
          this.heading=(this.heading+180)%360;
          this.patrolTarget=this.pickPatrolTarget();
        }
      }
      this.latlng=next;
      this.marker.setLatLng(this.latlng);
      this.cone.setLatLngs(this.computeCone());
    }
  }

  // --- Spillkontroll ---
  function clearGhosts(){
    ghosts.splice(0,ghosts.length);
    map.eachLayer(l=>{
      const isPlayer=(playerMarker && l===playerMarker) || (playerAccuracy && l===playerAccuracy);
      const isBoundary=(l===boundaryLayer);
      const isObstacleGroup=(l===obstaclesLayer);
      if (l instanceof L.CircleMarker || (l instanceof L.Polygon && l!==boundaryLayer)){
        if (!isPlayer && !isBoundary && !isObstacleGroup) map.removeLayer(l);
      }
    });
    if (playerMarker && !map.hasLayer(playerMarker)) playerMarker.addTo(map);
    if (playerAccuracy && !map.hasLayer(playerAccuracy)) playerAccuracy.addTo(map);
    if (boundaryLayer && !map.hasLayer(boundaryLayer)) boundaryLayer.addTo(map);
    if (obstaclesLayer && !map.hasLayer(obstaclesLayer)) obstaclesLayer.addTo(map);

    // S√∏rg for at boundaryLayer alltid er synlig
    if (boundaryLayer && !map.hasLayer(boundaryLayer)) {
      boundaryLayer.addTo(map);
    }
  }

  function startStopwatch(){
    Game.startedAt = Date.now();
    Game.shrunk = false;
    stopwatchEl.style.display='block';
    const update = ()=>{
      const ms = Date.now() - Game.startedAt;
      const s = Math.floor(ms/1000);
      const m = Math.floor(s/60);
      const ss = (s%60).toString().padStart(2,'0');
      stopwatchEl.textContent = `‚è±Ô∏è ${m}:${ss}`;
      // Krympetid i sekunder (kan endres som spillvariabel)
      const shrinkTime = Game.shrinkTimeSec || 120;
      if (!Game.shrunk && s >= shrinkTime) { // 2 minutter eller valgt tid
        shrinkBoundaryTo80();
        // hvis spiller havner utenfor etter krymp -> flytt tilbake mot sentrum et lite steg
        if (playerLatLng && !pointInside(boundaryPoly, playerLatLng)) {
          flashWarn('Omr√•det krympet! Du var utenfor ‚Äì flyt tilbake.');
          // flytt et hakk mot sentrum
          let centerLL;
          if (boundaryIsCircle && boundaryCircleCenter) centerLL = boundaryCircleCenter;
          else {
        const c = turf.centroid(boundaryPoly).geometry.coordinates;
        centerLL = L.latLng(c[1], c[0]);
          }
          const br = bearingTo(playerLatLng, centerLL);
          const step = 3; // meter
          let tmp = playerLatLng;
          for (let i = 0; i < 60 && !pointInside(boundaryPoly, tmp); i++) {
        tmp = moveFrom(tmp, br, step);
          }
          // kun sett hvis ikke i hindring og line-of-sight fra original pos ikke krysser hindring
          if (
        !pointInsideAnyObstacle(tmp) &&
        lineWithin(boundaryPoly, playerLatLng, tmp) &&
        !lineIntersectsAnyObstacle(playerLatLng, tmp)
          ) {
        ensurePlayer(tmp, null);
          }
        }
      }
    };
    if (Game.stopwatchTimer) clearInterval(Game.stopwatchTimer);
    Game.stopwatchTimer = setInterval(update, 300);
    update();
  }
  function stopStopwatch(){
    if (Game.stopwatchTimer){ clearInterval(Game.stopwatchTimer); Game.stopwatchTimer=null; }
    stopwatchEl.style.display='none';
  }

    function spawnGhost(options) {
    if (!boundaryPoly) return null;
    const bb = turf.bbox(boundaryPoly);
    let tries = 0;
    while (tries < 1000) {
      tries++;
      const rnd = turf.randomPoint(1, { bbox: bb }).features[0];
      if (!turf.booleanPointInPolygon(rnd, boundaryPoly)) continue;
      const [lng, lat] = rnd.geometry.coordinates;
      const p = L.latLng(lat, lng);
      // Make sure ghost spawns away from player
      if (playerLatLng && metersBetween(p, playerLatLng) < 100) continue;
      return new Ghost(p, options);
    }
    return null;
  }

  function startGame(){
    if (!playerLatLng){ alert('Sett spillerposisjon (GPS eller trykk i kartet).'); return; }
    if (!boundaryPoly) {
      ensureDefaultBoundary(playerLatLng); // 500 m sirkel
    }    clearGhosts();
    caughtEl.style.display='none';

    const n=Math.max(1, Math.min(100, Number(inputGhosts.value||3)));
    const speed=Number(inputSpeed.value||1.2);
    const fov=Number(inputFov.value||95);
    const viewDist=Number(inputViewDist.value||70);
    const prox=Number(inputProx.value||0);

    const bb=turf.bbox(boundaryPoly);
    let created=0, safety=0;
    while(created<n && safety<2000){
      safety++;
      const rnd=turf.randomPoint(1,{bbox:bb}).features[0];
      if (!turf.booleanPointInPolygon(rnd, boundaryPoly)) continue;
      const [lng,lat]=rnd.geometry.coordinates;
      const p=L.latLng(lat,lng);
      // Ikke spawn inni hindring
      if (pointInsideAnyObstacle(p)) continue;
      ghosts.push(new Ghost(p, {speed,fov,viewDist,proximity:prox}));
      created++;
    }

    setStatus(`Sp√∏kelser klare: ${ghosts.length}. Gjem deg n√•!`);

    // Keep the existing boundary configuration
    drawBoundary(boundaryPoly);

    Game.state=STATE.COUNTDOWN;
    countdownEl.style.display='block';
    let count=1, elapsed=0;
    countdownEl.textContent=`${count}`;
    const startTime = Date.now();
    const countdownUpdate = () => {
      const elapsedSec = Math.floor((Date.now() - startTime) / 1000);
      const remaining = Game.hideSeconds - elapsedSec;
      
      if (remaining <= 0) {
        clearInterval(timer);
        countdownEl.style.display = 'none';
        runLoop();
      } else {
        countdownEl.textContent = remaining;
      }
    };
    countdownUpdate(); // Show initial number
    const timer = setInterval(countdownUpdate, 1000);
  }

  function runLoop(){
    Game.state=STATE.RUNNING;
    if (Game.timer) clearInterval(Game.timer);
    Game.timer=setInterval(()=>tick(Game.tickMs/1000), Game.tickMs);
    setStatus('Spillet er i gang! Hold deg unna sp√∏kelsenes synsfelt.');
    startStopwatch();
  }

  function tick(dt){
    if (Game.state!==STATE.RUNNING || !playerLatLng) return;
    
    // Check if it's time to spawn a new ghost
    const now = Date.now();
    if (!Game.lastGhostSpawn) {
      Game.lastGhostSpawn = now;
    } else if (ghosts.length < Game.maxGhosts && 
               (now - Game.lastGhostSpawn) / 1000 >= Game.spawnGhostInterval) {
      const speed = Number(inputSpeed.value || 1.2);
      const fov = Number(inputFov.value || 95);
      const viewDist = Number(inputViewDist.value || 70);
      const prox = Number(inputProx.value || 0);
      
      const newGhost = spawnGhost({ speed, fov, viewDist, proximity: prox });
      if (newGhost) {
        ghosts.push(newGhost);
        Game.lastGhostSpawn = now;
        setStatus(`Et nytt sp√∏kelse har dukket opp! (${ghosts.length}/${Game.maxGhosts})`);
      }
    }
    
    let playerFound = false;
    const tasks = [];
    
    // Quick first pass: check proximity only (fastest check)
    for(const g of ghosts){
      const d = metersBetween(g.latlng, playerLatLng);
      if (d <= g.proximity) {
        playerFound = true;
        break;
      }
      // If not in proximity, queue up for full visibility check
      if (d <= g.viewDist) {
        tasks.push(g);
      }
      // Update movement regardless
      g.steer(dt, playerLatLng, ghosts);
    }
    
    // If player not found by proximity, do full visibility checks
    if (!playerFound && tasks.length > 0) {
      for(const g of tasks){
        if (g.seesPlayer(playerLatLng)){ 
          playerFound = true;
          break;
        }
      }
    }
    
    if (playerFound) {
      gameOver();
    }
  }

  function gameOver(){
    Game.state=STATE.CAUGHT;
    if (Game.timer){ clearInterval(Game.timer); Game.timer=null; }
    stopStopwatch();
    
    // Calculate time played
    const timePlayedMs = Date.now() - Game.startedAt;
    const timePlayedSec = Math.floor(timePlayedMs / 1000);
    
    // Check for high score
    checkHighScore(timePlayedSec, ghosts.length).then(() => {
      $('overlay').style.display='block';
      caughtEl.style.display='block';
      loadLeaderboard(); // Refresh leaderboard display
      setStatus('Du ble funnet! Trykk Reset for ny runde.');
    });
  }

  function resetGame(){
    Game.state=STATE.IDLE;
    if (Game.timer){ clearInterval(Game.timer); Game.timer=null; }
    stopStopwatch();
    countdownEl.style.display='none';
    caughtEl.style.display='none';
    $('overlay').style.display='none';
    clearGhosts();
    Game.shrunk=false;
    Game.lastGhostSpawn=null;
    setStatus('Klar for ny runde.');
  }

  // Knapper
  btnStart.addEventListener('click', ()=>{
    if (Game.state===STATE.RUNNING || Game.state===STATE.COUNTDOWN) return;
    startGame();
  });
  btnReset.addEventListener('click', resetGame);
  
  // Click handlers for game over screen
  $('overlay').addEventListener('click', resetGame);
  caughtEl.addEventListener('click', resetGame);

  // Init status
  setStatus('Klar til start!');
})();
</script>
</body>
</html>